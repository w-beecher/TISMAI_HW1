# Description
This is a "compiler" I wrote a few years ago now for an introductory compilers course at my Alma Mater.  The purpose is to convert Rust source files into an executable, though in practice this only covers a subset of the Rust languague.  This setup uses Flex for the lexing and Bison for the parsing.  Due to time constraints in the course, this does not compile directly to assembly from intermediate code but instead transpiles into assembly-like C code and invokes GCC (A future personal project is to actually implement the assembly portion, which is really the interesting part of a compiler anyways).

I do still have a number of example test files which are provided, which do at least show functionality on the aspects that were included.  A large portion of this work was adding in semi-informative error messages; you are free to mess around with source files to see what you can find, though without the languague specification this might produce some really strange results or errors in some cases.

# Setup
I have provided a Dockerfile to create a virtual enviornment, which should ensure that everything is set up properly automatically (Assuming you're running Ubuntu).


The image can be created via `sudo docker build -t hw-1-image .`, or whatever other name you'd like instead of hw-1-image.  This should take roughly a minute or two.

This can then be run via `sudo docker run -it hw-1-image`.  

When finished, you can remove the image however you'd like.

# Running & Usage
The Dockerfile will automatically run the makefile, so all compilation should be completed already.  The built executable is `fec`.  You are free to use the makefile yourself to `make clean` or re`make` if you wish.

To see what it's doing, I have included a `tests/` directory which contains a number of example run files illustrating a variety of features (mostly to cover functionality on the original rubric of this assignment).  Executables are always placed in the same directory as the source files, NOT in the current working directory.  Finally, be aware that some files are testing features that are not immediately obvious in the title: for example, `flow control/if.rs` also contains a test for boolean short-circuiting by including a divide-by-zero operation in the if statement.  I would reccomend reading these test files to ensure that the output matches what one would expect; they are very very simple.

Usage: `./fec [executable]`.  For example, in the root directory, `./fec tests/builtins/read.rs` and the executable can be run via `./tests/builtins/read`.

Finally, this supports a number of command line argument tags.  The ones that may be of interest are:
- `-icode` which outputs to stdout a representation of assembly-like intermediate code
- `-c` which compiles into an object file (i.e., skips the linking step)
- `-s` which retains a TAC.c representation of the intermediate code

# Reflection
Firstly, I believe this code only partially does what I would want it to.  What I am most proud of is the generation into intermediate code; up to this point, I took great pains to make sure this was as close to assembly language as possible, and I think I did a pretty good job at it.  Although it's definitely far from optimal, I do think my output is pretty reasonable and without too much excessive bloat. I also wrote the grammar entirely from scratch, and I'm pretty proud of how that turned out as well, especially compared to the results some of my colleagues at the time had.  Although this could definitely use some expansion and cleaning up, I think it's among the more presentable aspects of the overall repository. A compiler is a pretty involved project, and especially for work created by an undergraduate at the time, I think I can at least be relatively proud of these aspects of it and simply getting something working at all.

Unfortunately, I wasn't able to actually work on the transition to real assembly code in the time I had during this course -- this is the most interesting part of a compiler to me, tackling register allocation and code optimization procedures.  I'm pretty disappointed that I wasn't able to get around to this, and I hope that I have the time to actually implement these as features eventually.  In reality this isn't really a compiler but more a transpiler to assembly-like C code.  These are also the biggest unanswered questions: the course I took didn't have time for these topics and so my understanding isn't too great on these processes (despite them being arguably the most important ones in the entire concept of a compiler).
The code here also only works on a pretty restrictive subset of the language, ignoring some of Rust's most interesting / useful / complex functionality, so I would hesitate to even say it "works on Rust."  Although I am proud of the results (up to icode generation, at least), I do think it has a very long way to go before I can actually consider this a meaningful Rust compiler.

I would definitely say there's quite a bit here that I am embarrassed by, as well.  This code was made for a class which was structured such that every additional step in the compiler process was to be completed as a separate module.  The process was not very well thought out in my opinion; our language specification was not even defined for the first month, and even once it was defined it went through multiple changes a week, requiring constant code refactors to keep everything up to date.  Between these two things, the overall structure of the code is incredibly messy.  Given the iterative approach of building more and more modules, I also feel that this code is far more bloated than it needs to be and doesn't always form a logical whole.  For example, modules for printing out dot images or printout for tree structures were helpful for initial debugging, but with the compiler itself mostly finished, these just add extra complexity and confusion to the repository that is wholly unnecessary. Different modules should probably be moved into sub-folders to give a more descriptive logical grouping instead of keeping everything in the same folder. Having to constantly build new features on top of existing ones led to a very confusing and roundabout approach to compiler design; the passes over the syntax tree are not really done in a very logical or efficient order, and very little of the memory allocated after the building of the syntax tree is actually freed.
Overall, I think that a major refactor would do this project well, if not restarting from the ground up. The coding style needs to be cleaned up, and the overall approach should be made more logically consistent with fewer interdependencies across modules; I've definitely improved a lot as a programmer since making this.

Finally, there are actually a few bugs in this that I'm not entirely sure about.  The one that comes most to mind is the format() builtin, which currently only accepts only 1 {} input even though it should accept multiple.  There's also just a lot I don't really understand about *why* the language set we were given was so restrictive -- perhaps we shouldn't have been told to write a compiler for Rust if Rust was too complex of a language to expect any of us to make a functional compiler for it? 
For unanswered questions, I think it would be a more interesting exercise to actually write the lexer and parser by hand: although I know how they work in theory, this doesn't translate to an actual practical understanding, and relying on tools like Bison and Flex hurt my ability to really understand what was going on in this part of the process.  Of course, as mentioned, the biggest questions I have are mostly on register allocation and optimization in the generation of final assembly code -- these are vital to any reasonable compiler, and I don't think my knowledge of these topics are sufficient.

